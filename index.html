// ========== KHỞI TẠO CANVAS FABRIC.JS ==========
const canvas = new fabric.Canvas('main-canvas', {
    backgroundColor: 'transparent',
    preserveObjectStacking: true,
    selection: true,
    selectionKey: 'shiftKey'
});

function resizeCanvas() {
    const container = document.querySelector('.canvas-container');
    canvas.setWidth(container.clientWidth);
    canvas.setHeight(container.clientHeight);
    
    // Cập nhật kích thước cho lasso canvas
    const lassoCanvas = document.getElementById('lassoCanvas');
    const lassoOverlay = document.getElementById('lassoOverlay');
    if (lassoCanvas) {
        lassoCanvas.width = container.clientWidth;
        lassoCanvas.height = container.clientHeight;
    }
    if (lassoOverlay) {
        lassoOverlay.style.width = container.clientWidth + 'px';
        lassoOverlay.style.height = container.clientHeight + 'px';
    }
    
    canvas.renderAll();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// ========== BIẾN TOÀN CỤC ==========
let mockupImage = null;
let displacementMap = null; 
let textures = [];
let zoomLevel = 1;
let currentToolMode = 'select';

let drawingBrush = {
    color: '#4ecdc4',
    width: 5,
    opacity: 1.0
};

// ========== BIẾN CHO CÔNG CỤ LASO CẢI TIẾN ==========
let isLassoMode = false;
let lassoPoints = [];
let lassoCanvas = document.getElementById('lassoCanvas');
let lassoCtx = lassoCanvas ? lassoCanvas.getContext('2d') : null;
let isDrawingLasso = false;
let originalSelectionState = true;

// ========== UNDO/REDO SYSTEM ==========
let history = [];
let historyIndex = -1;
const MAX_HISTORY = 50;

function saveToHistory() {
    if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
    }
    
    const state = canvas.toDatalessJSON(['globalCompositeOperation']);
    history.push(state);
    historyIndex++;
    
    if (history.length > MAX_HISTORY) {
        history.shift();
        historyIndex--;
    }
    
    updateHistoryButtons();
    updateHistoryStatus();
}

function updateHistoryButtons() {
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    undoBtn.disabled = historyIndex <= 0;
    redoBtn.disabled = historyIndex >= history.length - 1;
}

function updateHistoryStatus() {
    document.getElementById('historyStatus').textContent = 
        `${historyIndex}/${history.length-1}`;
}

canvas.on('object:modified', saveToHistory);
canvas.on('object:added', saveToHistory);
canvas.on('object:removed', saveToHistory);

// ========== CÔNG CỤ VẼ TỰ DO ==========
function activateDrawingMode() {
    currentToolMode = 'draw';
    canvas.isDrawingMode = true;
    canvas.selection = false;
    
    canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
    canvas.freeDrawingBrush.color = drawingBrush.color;
    canvas.freeDrawingBrush.width = drawingBrush.width;
    canvas.freeDrawingBrush.opacity = drawingBrush.opacity;
    
    document.getElementById('drawingControls').style.display = 'flex';
    updateToolButtons();
    updateStatus('Chế độ vẽ tự do - Kéo chuột để vẽ');
}

function deactivateDrawingMode() {
    canvas.isDrawingMode = false;
    canvas.selection = true;
    document.getElementById('drawingControls').style.display = 'none';
}

document.getElementById('drawBtn').addEventListener('click', function() {
    if (currentToolMode === 'draw') {
        setToolMode('select');
    } else {
        setToolMode('draw');
    }
});

document.getElementById('drawingColor').addEventListener('input', function(e) {
    drawingBrush.color = e.target.value;
    if (currentToolMode === 'draw') {
        canvas.freeDrawingBrush.color = drawingBrush.color;
    }
    e.target.style.background = drawingBrush.color;
});

document.getElementById('drawingWidth').addEventListener('input', function(e) {
    drawingBrush.width = parseInt(e.target.value);
    document.getElementById('drawingWidthValue').textContent = drawingBrush.width + 'px';
    
    if (currentToolMode === 'draw') {
        canvas.freeDrawingBrush.width = drawingBrush.width;
    }
});

document.getElementById('drawingOpacity').addEventListener('input', function(e) {
    drawingBrush.opacity = parseInt(e.target.value) / 100;
    document.getElementById('drawingOpacityValue').textContent = e.target.value + '%';
    
    if (currentToolMode === 'draw') {
        canvas.freeDrawingBrush.opacity = drawingBrush.opacity;
    }
});

document.getElementById('clearDrawing').addEventListener('click', function() {
    const drawingObjects = canvas.getObjects().filter(obj => 
        obj.type === 'path' && obj.name === 'free_drawing'
    );
    
    drawingObjects.forEach(obj => {
        canvas.remove(obj);
    });
    
    canvas.renderAll();
    saveToHistory();
    updateStatus('Đã xóa tất cả nét vẽ');
});

canvas.on('path:created', function(e) {
    e.path.name = 'free_drawing';
    saveToHistory();
});

// ========== CÔNG CỤ LASO CẢI TIẾN ==========
function activateLassoMode() {
    currentToolMode = 'lasso';
    isLassoMode = true;
    isDrawingLasso = false;
    lassoPoints = [];
    
    // Lưu trạng thái canvas ban đầu
    originalSelectionState = canvas.selection;
    canvas.selection = false;
    canvas.defaultCursor = 'crosshair';
    
    // Khởi tạo/Lấy canvas lasso
    const lassoOverlay = document.getElementById('lassoOverlay');
    lassoCanvas = document.getElementById('lassoCanvas');
    if (!lassoCtx) {
        lassoCtx = lassoCanvas.getContext('2d');
    }
    
    lassoCanvas.width = canvas.width;
    lassoCanvas.height = canvas.height;
    
    // Hiển thị overlay
    lassoOverlay.style.display = 'block';
    lassoOverlay.style.pointerEvents = 'auto';
    
    updateToolButtons();
    updateStatus('Laso Tool: Kéo chuột để vẽ vùng chọn, nhấn Enter để hoàn thành');
}

function startLassoDrawing(event) {
    const targetElement = event.target || event.srcElement;
    if (!isLassoMode || targetElement !== lassoCanvas) return;
    
    // Ngăn chặn hành vi mặc định
    event.preventDefault();
    event.stopPropagation();
    
    isDrawingLasso = true;
    
    // Lấy tọa độ chuột (relative to canvas)
    const rect = lassoCanvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    
    lassoPoints = [{x, y}];
    
    // Bắt đầu vẽ trên lasso canvas
    lassoCtx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);
    lassoCtx.beginPath();
    lassoCtx.moveTo(x, y);
    lassoCtx.strokeStyle = '#ff0000';
    lassoCtx.lineWidth = 2;
    lassoCtx.lineJoin = 'round';
    lassoCtx.lineCap = 'round';
}

function continueLassoDrawing(event) {
    if (!isLassoMode || !isDrawingLasso) return;
    
    event.preventDefault();
    event.stopPropagation();
    
    const rect = lassoCanvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    
    lassoPoints.push({x, y});
    
    // Vẽ đường trên lasso canvas
    lassoCtx.lineTo(x, y);
    lassoCtx.stroke();
}

function endLassoDrawing(event) {
    if (!isLassoMode || !isDrawingLasso) return;
    
    event.preventDefault();
    isDrawingLasso = false;
    finishLassoSelection(); 
}

function finishLassoSelection() {
    if (!isLassoMode || lassoPoints.length < 3) {
        updateStatus('Vui lòng vẽ vùng chọn với ít nhất 3 điểm');
        return;
    }
    
    // Đóng đường vẽ
    lassoCtx.lineTo(lassoPoints[0].x, lassoPoints[0].y);
    lassoCtx.closePath();
    lassoCtx.fillStyle = 'rgba(78, 205, 196, 0.3)'; // Màu xanh teal bán trong suốt
    lassoCtx.fill();
    lassoCtx.strokeStyle = '#4ecdc4'; // Màu viền
    lassoCtx.lineWidth = 3;
    lassoCtx.stroke();
    
    updateStatus('Đã tạo vùng chọn. Nhấn Delete để xóa phần bên trong vùng này.');
}

function deleteLassoArea() {
    if (!isLassoMode || lassoPoints.length < 3) {
        updateStatus('Vui lòng tạo vùng chọn trước khi xóa');
        return;
    }
    
    const activeObj = canvas.getActiveObject();
    if (!activeObj || activeObj.name !== 'texture' || activeObj.isEditing) {
        updateStatus('Vui lòng chọn một vật liệu (Texture) trước khi xóa vùng chọn');
        return;
    }
    
    // 1. Tạo một canvas ẩn để xử lý
    const tempCanvas = document.createElement('canvas');
    const ctx = tempCanvas.getContext('2d');
    
    // Lấy kích thước texture GỐC
    const img = activeObj.getElement();
    tempCanvas.width = img.naturalWidth || img.width;
    tempCanvas.height = img.naturalHeight || img.height;
    
    // 2. Vẽ texture gốc
    ctx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
    
    // 3. Tạo path từ các điểm lasso (chuyển đổi tọa độ)
    ctx.beginPath();
    
    // Chuyển đổi tọa độ từ canvas SANG image
    const matrix = activeObj.calcTransformMatrix();
    const invertedMatrix = fabric.util.invertTransform(matrix);
    
    // Điểm đầu tiên
    const firstTransformed = fabric.util.transformPoint(
        new fabric.Point(lassoPoints[0].x, lassoPoints[0].y),
        invertedMatrix
    );
    ctx.moveTo(firstTransformed.x, firstTransformed.y);
    
    // Vẽ đường qua các điểm
    for (let i = 1; i < lassoPoints.length; i++) {
        const transformedPoint = fabric.util.transformPoint(
            new fabric.Point(lassoPoints[i].x, lassoPoints[i].y),
            invertedMatrix
        );
        ctx.lineTo(transformedPoint.x, transformedPoint.y);
    }
    
    // Đóng path
    ctx.closePath();
    
    // 4. Xóa phần bên trong path (Destination-Out)
    ctx.globalCompositeOperation = 'destination-out';
    ctx.fill();
    
    // 5. Tạo ảnh mới và thay thế
    fabric.Image.fromURL(tempCanvas.toDataURL(), function(newImg) {
        // Sao chép thuộc tính của đối tượng cũ
        newImg.set({
            left: activeObj.left,
            top: activeObj.top,
            scaleX: activeObj.scaleX,
            scaleY: activeObj.scaleY,
            angle: activeObj.angle,
            opacity: activeObj.opacity,
            skewX: activeObj.skewX,
            skewY: activeObj.skewY,
            globalCompositeOperation: activeObj.globalCompositeOperation,
            hasControls: true,
            hasBorders: true,
            cornerStyle: 'circle',
            cornerColor: '#4ecdc4',
            borderColor: '#4ecdc4',
            cornerSize: 12,
            transparentCorners: false,
            name: 'texture'
        });
        
        canvas.remove(activeObj);
        canvas.add(newImg);
        canvas.setActiveObject(newImg);
        
        // Dọn dẹp lasso và lưu lịch sử
        cleanupLasso();
        canvas.renderAll();
        saveToHistory();
        updateStatus('Đã xóa phần bên trong vùng chọn thành công!');
    });
}

function cleanupLasso() {
    // Xóa canvas lasso
    if (lassoCtx) {
        lassoCtx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);
    }
    
    // Ẩn overlay
    const lassoOverlay = document.getElementById('lassoOverlay');
    lassoOverlay.style.display = 'none';
    lassoOverlay.style.pointerEvents = 'none';
    
    lassoPoints = [];
    isDrawingLasso = false;
    
    // Khôi phục lại trạng thái canvas
    canvas.selection = originalSelectionState;
    canvas.defaultCursor = 'default';
    
    canvas.renderAll();
}

// ========== WARP TỰ ĐỘNG NÂNG CAO ==========
async function applyAutoWarp() {
    const activeObj = canvas.getActiveObject();
    if (!activeObj || activeObj.name !== 'texture') {
        updateStatus('Vui lòng chọn một vật liệu để warp tự động (W)');
        return;
    }
    
    // 1. Tạo displacement map nếu chưa có
    if (!displacementMap) {
        updateStatus('Đang tạo displacement map tự động... (Bước 1/2)');
        try {
            await createAutoDisplacementMap();
        } catch (e) {
            updateStatus(e.message);
            return;
        }
    }
    
    updateStatus('Đang áp dụng hiệu ứng warp... (Bước 2/2)');
    
    // 2. Áp dụng warp
    applyWarpWithSettings(activeObj, {
        dispIntensity: 40, // Cường độ Warp mặc định
        warpX: 0,
        warpY: 0,
        bulge: 0,
        pinch: 0,
        wave: 0,
        blend: 90 // Độ hòa trộn màu mặc định cao hơn
    });
}

function createAutoDisplacementMap() {
    return new Promise((resolve, reject) => {
        if (!mockupImage) {
            reject(new Error('Chưa có mockup - Vui lòng tải ảnh mockup trước!'));
            return;
        }
        
        const mockupElement = mockupImage.getElement();
        const tempCanvas = document.createElement('canvas');
        const ctx = tempCanvas.getContext('2d');
        
        // Kích thước của map sẽ bằng kích thước hiển thị của mockup
        const bounds = mockupImage.getBoundingRect();
        tempCanvas.width = bounds.width;
        tempCanvas.height = bounds.height;
        
        // Tính toán tọa độ để chỉ vẽ phần mockup (loại bỏ padding/crop nếu có)
        const scaleX = tempCanvas.width / mockupImage.width;
        const scaleY = tempCanvas.height / mockupImage.height;
        
        ctx.drawImage(mockupElement, 
            0, 0, mockupImage.width, mockupImage.height,
            0, 0, tempCanvas.width, tempCanvas.height
        );
        
        // 1. Chuyển sang đen trắng và tăng độ tương phản nhẹ (TỐT HƠN)
        const imageData = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const data = imageData.data;
        
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // Tính luminance
            let luminance = 0.299 * r + 0.587 * g + 0.114 * b;
            
            // Tăng tương phản nhẹ (ví dụ: nhân với 1.2)
            luminance = (luminance - 128) * 1.2 + 128;
            luminance = Math.max(0, Math.min(255, luminance));
            
            data[i] = luminance;
            data[i + 1] = luminance;
            data[i + 2] = luminance;
        }
        
        ctx.putImageData(imageData, 0, 0);
        
        // 2. Áp dụng blur nhẹ (Làm mềm các nếp gấp)
        ctx.filter = 'blur(2px)';
        ctx.drawImage(tempCanvas, 0, 0);
        ctx.filter = 'none';
        
        // 3. Tạo displacement map từ canvas
        const img = new Image();
        img.onload = function() {
            // Đảm bảo map có kích thước bằng kích thước hiển thị của mockup
            displacementMap = img; 
            updateStatus('Đã tạo Displacement Map tự động thành công');
            resolve();
        };
        img.onerror = reject;
        img.src = tempCanvas.toDataURL();
    });
}

function applyWarpWithSettings(obj, settings) {
    const imgElement = obj.getElement();
    
    try {
        const fxCanvas = fx.canvas();
        const texture = fxCanvas.texture(imgElement);
        
        fxCanvas.draw(texture).update();
        
        // Áp dụng Displacement Map (Height Field)
        if (settings.dispIntensity > 0 && displacementMap) {
            const displacementTexture = fxCanvas.texture(displacementMap);
            // Cường độ Warp: dispIntensity/100 * 0.15 (0.15 là giá trị max hợp lý)
            fxCanvas.heightField(displacementTexture, settings.dispIntensity / 100 * 0.15).update();
        }
        
        // Có thể thêm Bulge/Pinch/Wave tùy chỉnh ở đây nếu cần (tạm bỏ qua cho Auto)
        const center = [0.5, 0.5];
        if (settings.bulge > 0) {
            fxCanvas.bulgePinch(center[0], center[1], settings.bulge / 100 * 0.5, 0.9).update();
        }
        
        const warpedUrl = fxCanvas.toDataURL();
        
        fabric.Image.fromURL(warpedUrl, function(warpedImg) {
            // Sao chép các thuộc tính và đặt Blending Mode
            warpedImg.set({
                left: obj.left,
                top: obj.top,
                scaleX: obj.scaleX,
                scaleY: obj.scaleY,
                angle: obj.angle,
                skewX: obj.skewX + settings.warpX * 0.3,
                skewY: obj.skewY + settings.warpY * 0.3,
                globalCompositeOperation: 'multiply', // Blending mode cho hiệu ứng bóng đổ
                opacity: settings.blend / 100, // Sử dụng blend làm opacity
                hasControls: true,
                hasBorders: true,
                cornerStyle: 'circle',
                cornerColor: '#4ecdc4',
                borderColor: '#4ecdc4',
                cornerSize: 12,
                transparentCorners: false,
                name: 'texture'
            });
            
            canvas.remove(obj);
            canvas.add(warpedImg);
            canvas.setActiveObject(warpedImg);
            canvas.renderAll();
            saveToHistory();
            updateStatus('Đã áp dụng warp tự động với hiệu ứng Displacement Map!');
        });
    } catch (e) {
        updateStatus('Lỗi Warp: Vui lòng kiểm tra console.');
        console.error('Warp Error:', e);
    }
}

// ========== CHUYỂN ĐỔI CÔNG CỤ ==========
function setToolMode(mode) {
    // Dọn dẹp mode cũ
    if (currentToolMode === 'draw') {
        deactivateDrawingMode();
    } else if (currentToolMode === 'lasso') {
        cleanupLasso();
        // Xóa các event listener cũ
        lassoCanvas.removeEventListener('mousedown', handleLassoMouseDown);
        lassoCanvas.removeEventListener('mousemove', handleLassoMouseMove);
        document.removeEventListener('mouseup', handleLassoMouseUp);
    }
    
    currentToolMode = mode;
    
    document.querySelectorAll('.tools .tool-btn').forEach(btn => {
        btn.classList.remove('active-tool');
    });

    // Thiết lập các event handlers cho Laso
    if (mode === 'lasso') {
        document.getElementById('lassoBtn').classList.add('active-tool');
        activateLassoMode();
        
        // Thêm event listeners vào lassoCanvas
        lassoCanvas.addEventListener('mousedown', handleLassoMouseDown);
        lassoCanvas.addEventListener('mousemove', handleLassoMouseMove);
        document.addEventListener('mouseup', handleLassoMouseUp); // mouseup trên document để bao quát
    } 
    else if (mode === 'hand') {
        document.getElementById('handToolBtn').classList.add('active-tool');
        canvas.selection = false;
        canvas.defaultCursor = 'grab';
        canvas.hoverCursor = 'grab';
        updateStatus('Chế độ Bàn Tay (Pan) được kích hoạt');
    } 
    else if (mode === 'draw') {
        document.getElementById('drawBtn').classList.add('active-tool');
        activateDrawingMode();
    }
    else {
        document.getElementById('transformBtn').classList.add('active-tool');
        canvas.selection = true;
        canvas.defaultCursor = 'default';
        canvas.hoverCursor = 'move';
        updateStatus('Chế độ Select/Transform được kích hoạt');
    }
    
    canvas.renderAll();
}

// Event handlers cho lasso
function handleLassoMouseDown(e) {
    if (isLassoMode) {
        startLassoDrawing(e);
    }
}

function handleLassoMouseMove(e) {
    if (isLassoMode) {
        continueLassoDrawing(e);
    }
}

function handleLassoMouseUp(e) {
    if (isLassoMode && isDrawingLasso) {
        endLassoDrawing(e);
    }
}

document.getElementById('handToolBtn').addEventListener('click', () => setToolMode('hand'));
document.getElementById('transformBtn').addEventListener('click', () => setToolMode('select'));
document.getElementById('lassoBtn').addEventListener('click', function() {
    if (currentToolMode === 'lasso') {
        setToolMode('select');
    } else {
        setToolMode('lasso');
    }
});
document.getElementById('warpAutoBtn').addEventListener('click', applyAutoWarp);

// ========== ZOOM & PAN (KHÔNG ĐỔI) ==========
let isPanning = false;

canvas.on('mouse:down', function(opt) {
    const evt = opt.e;
    if (currentToolMode === 'draw' || currentToolMode === 'lasso') {
        return;
    }
    
    if (evt.ctrlKey || evt.altKey || currentToolMode === 'hand') { 
        isPanning = true;
        canvas.selection = false; 
        canvas.lastPosX = evt.clientX;
        canvas.lastPosY = evt.clientY;
        if (currentToolMode === 'hand') {
            canvas.defaultCursor = 'grabbing';
        }
    }
});

canvas.on('mouse:move', function(opt) {
    if (isPanning && zoomLevel >= 1) {
        const evt = opt.e;
        const vpt = canvas.viewportTransform;
        
        vpt[4] += evt.clientX - canvas.lastPosX;
        vpt[5] += evt.clientY - canvas.lastPosY;
        
        limitPan(vpt);
        canvas.requestRenderAll();
        
        canvas.lastPosX = evt.clientX;
        canvas.lastPosY = evt.lastPosY = evt.clientY;
    }
});

canvas.on('mouse:up', function(opt) {
    isPanning = false;
    if (currentToolMode === 'select') {
        canvas.selection = true;
        canvas.defaultCursor = 'default';
    } else if (currentToolMode === 'hand') {
         canvas.defaultCursor = 'grab';
         canvas.selection = false; 
    }
    canvas.setViewportTransform(canvas.viewportTransform); 
});

function limitPan(vpt) {
    const viewportWidth = canvas.getWidth();
    const viewportHeight = canvas.getHeight();
    const maxOffsetX = viewportWidth * (zoomLevel - 1) * 0.5;
    const maxOffsetY = viewportHeight * (zoomLevel - 1) * 0.5;

    if (vpt[4] > maxOffsetX) vpt[4] = maxOffsetX;
    if (vpt[4] < -maxOffsetX) vpt[4] = -maxOffsetX;
    if (vpt[5] > maxOffsetY) vpt[5] = maxOffsetY;
    if (vpt[5] < -maxOffsetY) vpt[5] = -maxOffsetY;
}

canvas.on('mouse:wheel', function(opt) {
    const delta = opt.e.deltaY;
    let newZoom = zoomLevel;

    if (delta > 0) newZoom /= 1.1;
    else if (delta < 0) newZoom *= 1.1;

    newZoom = Math.min(5, Math.max(0.1, newZoom));
    
    canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, newZoom);
    zoomLevel = newZoom;
    
    limitPan(canvas.viewportTransform);
    updateZoomDisplay();
    opt.e.preventDefault(); 
    opt.e.stopPropagation();
});

function updateZoomDisplay() {
    const percent = Math.round(zoomLevel * 100);
    document.getElementById('zoomLevel').textContent = percent + '%';
    document.getElementById('zoomStatus').textContent = percent + '%';
    canvas.renderAll();
}

function zoomToPoint(point, newZoom) {
    zoomLevel = Math.min(5, Math.max(0.1, newZoom));
    canvas.zoomToPoint(point, zoomLevel);
    updateZoomDisplay();
}

function resetZoom() { 
    canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
    zoomLevel = 1;
    canvas.setZoom(1);
    updateZoomDisplay();
    updateStatus("Zoom đã reset về 100%"); 
}

document.getElementById('zoomInCanvas').addEventListener('click', () => zoomToPoint(canvas.getCenter(), zoomLevel * 1.2));
document.getElementById('zoomOutCanvas').addEventListener('click', () => zoomToPoint(canvas.getCenter(), zoomLevel * 0.8));
document.getElementById('zoomResetCanvas').addEventListener('click', resetZoom);

// ========== UPLOAD FUNCTIONS (KHÔNG ĐỔI) ==========
document.getElementById('uploadMockupBtn').addEventListener('click', function() {
    document.getElementById('mockupFile').click();
});

document.getElementById('mockupFile').addEventListener('change', function(e) {
    if (e.target.files[0]) {
        const reader = new FileReader();
        reader.onload = function(event) {
            if (mockupImage) canvas.remove(mockupImage);
            
            fabric.Image.fromURL(event.target.result, function(img) {
                mockupImage = img;
                mockupImage.set({ 
                    selectable: false, 
                    evented: false, 
                    hasControls: false, 
                    hasBorders: false, 
                    name: 'mockup_bg' 
                });
                
                const scale = Math.min(canvas.width / img.width, canvas.height / img.height) * 0.9;
                
                img.scale(scale);
                img.set({
                    left: (canvas.width - img.width * scale) / 2,
                    top: (canvas.height - img.height * scale) / 2
                });
                
                canvas.add(img);
                canvas.sendToBack(img);
                updateStatus('Mockup đã được tải lên!');
                saveToHistory();
            });
        };
        reader.readAsDataURL(e.target.files[0]);
    }
});

document.getElementById('uploadTextureBtn').addEventListener('click', function() {
    document.getElementById('textureFiles').click();
});

document.getElementById('textureFiles').addEventListener('change', function(e) {
    const files = Array.from(e.target.files);
    const thumbnailsContainer = document.getElementById('textureThumbnails');
    
    files.forEach((file, index) => {
        const reader = new FileReader();
        reader.onload = function(event) {
            textures.push({
                id: Date.now() + index,
                url: event.target.result,
                name: file.name
            });
            
            const thumbnail = document.createElement('img');
            thumbnail.src = event.target.result;
            thumbnail.className = 'thumbnail';
            thumbnail.draggable = true;
            thumbnail.dataset.index = textures.length - 1;
            
            thumbnail.addEventListener('dragstart', function(e) {
                e.dataTransfer.setData('textureIndex', this.dataset.index);
            });
            thumbnailsContainer.appendChild(thumbnail);
        };
        reader.readAsDataURL(file);
    });
    updateStatus(`Đã tải lên ${files.length} ảnh vật liệu`);
});

canvas.on('drop', function(event) {
    if (currentToolMode === 'draw' || currentToolMode === 'lasso') {
        return;
    }
    
    event.e.preventDefault();
    
    const textureIndex = event.e.dataTransfer.getData('textureIndex');
    if (textureIndex === '') return;
    
    const index = parseInt(textureIndex);
    if (textures[index]) {
        const texture = textures[index];
        
        fabric.Image.fromURL(texture.url, function(img) {
            const scale = 200 / Math.max(img.width, img.height);
            
            img.set({
                left: event.e.offsetX - (img.width * scale) / 2,
                top: event.e.offsetY - (img.height * scale) / 2,
                scaleX: scale,
                scaleY: scale,
                globalCompositeOperation: 'multiply', 
                hasControls: true,
                hasBorders: true,
                cornerStyle: 'circle',
                cornerColor: '#4ecdc4',
                borderColor: '#4ecdc4',
                cornerSize: 12,
                transparentCorners: false,
                name: 'texture' 
            });
            
            canvas.add(img);
            canvas.setActiveObject(img);
            updateStatus(`Đã thêm "${texture.name}" vào mockup`);
            updateSelectedObject();
            saveToHistory();
        });
    }
});

canvas.on('dragover', function(event) { 
    event.e.preventDefault(); 
});

// ========== FIT BỀ MẶT (KHÔNG ĐỔI) ==========
document.getElementById('fitSurfaceBtn').addEventListener('click', function() {
    const activeObj = canvas.getActiveObject();
    if (!activeObj || !mockupImage) {
        updateStatus('Cần có mockup và vật liệu để fit bề mặt');
        return;
    }
    
    const mockupBounds = mockupImage.getBoundingRect();
    const fitScale = 0.8;
    
    const targetWidth = mockupBounds.width * fitScale;
    const targetHeight = mockupBounds.height * fitScale;
    
    const scaleX = targetWidth / activeObj.width;
    const scaleY = targetHeight / activeObj.height;
    const scale = Math.min(scaleX, scaleY);
    
    activeObj.set({
        scaleX: scale,
        scaleY: scale,
        left: mockupBounds.left + (mockupBounds.width - activeObj.width * scale) / 2,
        top: mockupBounds.top + (mockupBounds.height - activeObj.height * scale) / 2,
        angle: 0,
        skewX: 0,
        skewY: 0,
        opacity: 0.9,
        globalCompositeOperation: 'multiply'
    });
    
    activeObj.setCoords();
    canvas.renderAll();
    updateStatus('Đã fit ảnh theo bề mặt mockup');
    saveToHistory();
});

// ========== HOÀN TẤT TẤT CẢ (Đã chỉnh sửa logic Warp) ==========
document.getElementById('finishAllBtn').addEventListener('click', async function() {
    updateStatus('Đang xử lý hoàn tất tất cả...');
    
    try {
        // 1. Tạo displacement map nếu chưa có
        if (!displacementMap && mockupImage) {
            updateStatus('Đang tạo Displacement Map... (Bước 1/2)');
            await createAutoDisplacementMap();
        }
        
        // 2. Áp dụng warp cho tất cả vật liệu
        const textureObjects = canvas.getObjects().filter(obj => obj.name === 'texture');
        
        if (textureObjects.length > 0) {
            updateStatus(`Đang áp dụng warp cho ${textureObjects.length} vật liệu... (Bước 2/2)`);
            
            // Xử lý từng texture một cách đồng bộ
            for (const texture of textureObjects) {
                // Rất quan trọng: Phải đảm bảo canvas nhận biết đối tượng
                canvas.setActiveObject(texture);
                await new Promise(resolve => {
                    // Cần một slight delay để glfx có thể chạy xong
                    applyWarpWithSettings(texture, {
                        dispIntensity: 40,
                        warpX: 0,
                        warpY: 0,
                        bulge: 0,
                        pinch: 0,
                        wave: 0,
                        blend: 90
                    });
                    // Giả định warp chạy nhanh và resolve sau 500ms
                    setTimeout(resolve, 500); 
                });
            }
        }
        
        // 3. Mở modal save sau khi tất cả đã hoàn thành
        setTimeout(() => {
            document.getElementById('saveModal').classList.add('active');
            document.getElementById('saveOverlay').classList.add('active');
            updateStatus('Hoàn tất! Vui lòng đặt tên file và tải xuống.');
        }, 100);
        
    } catch (error) {
        updateStatus('Lỗi khi hoàn tất: ' + error.message);
        console.error(error);
    }
});

// ========== LƯU/XUẤT FILE (KHÔNG ĐỔI) ==========
const saveModal = document.getElementById('saveModal');
const saveOverlay = document.getElementById('saveOverlay');

document.getElementById('saveBtn').addEventListener('click', function() {
    saveModal.classList.add('active');
    saveOverlay.classList.add('active');
    updateStatus('Mở hộp thoại xuất file');
});

document.getElementById('cancelSave').addEventListener('click', closeSaveModal);
saveOverlay.addEventListener('click', closeSaveModal);

function closeSaveModal() {
    saveModal.classList.remove('active');
    saveOverlay.classList.remove('active');
}

document.getElementById('confirmSave').addEventListener('click', function() {
    const format = document.getElementById('exportFormat').value;
    const fileName = document.getElementById('exportFileName').value || 'mockup_k_pro';
    
    updateStatus('Đang tạo hình ảnh xuất file, vui lòng chờ...');
    
    const originalVpt = [...canvas.viewportTransform];
    const originalZoom = zoomLevel;
    
    canvas.discardActiveObject(); 
    
    canvas.getObjects().forEach(obj => {
        obj.hasControls = false;
        obj.hasBorders = false;
    });
    
    canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
    canvas.setZoom(1);
    canvas.renderAll();

    const dataURL = canvas.toDataURL({
        format: format,
        quality: 0.95
    });

    setTimeout(() => {
        canvas.setViewportTransform(originalVpt);
        canvas.setZoom(originalZoom);
        zoomLevel = originalZoom;
        updateZoomDisplay();
        
        canvas.getObjects().forEach(obj => {
            if (obj.name === 'texture') {
                obj.hasControls = true;
                obj.hasBorders = true;
            }
        });
        canvas.renderAll();
        
        const link = document.createElement('a');
        link.href = dataURL;
        link.download = `${fileName}.${format}`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        updateStatus(`Đã xuất file ${fileName}.${format} thành công!`);
        closeSaveModal();

    }, 50); 
});

// ========== CÁC CÔNG CỤ KHÁC ==========
document.getElementById('removeBtn').addEventListener('click', function() {
    if (currentToolMode === 'lasso' && lassoPoints.length >= 3) {
        deleteLassoArea();
    } else {
        const activeObj = canvas.getActiveObject();
        if (activeObj && activeObj !== mockupImage) {
            canvas.remove(activeObj);
            updateStatus('Đã xóa đối tượng');
            updateSelectedObject();
            saveToHistory();
        }
    }
});

document.getElementById('bringFrontBtn').addEventListener('click', function() {
    const activeObj = canvas.getActiveObject();
    if (activeObj) {
        activeObj.bringToFront();
        canvas.renderAll();
        updateStatus('Đã đưa lên lớp trên');
        saveToHistory();
    }
});

document.getElementById('sendBackBtn').addEventListener('click', function() {
    const activeObj = canvas.getActiveObject();
    if (activeObj && activeObj !== mockupImage) {
        activeObj.sendToBack();
        if (mockupImage) mockupImage.sendToBack();
        canvas.renderAll();
        updateStatus('Đã đưa xuống lớp dưới');
        saveToHistory();
    }
});

document.getElementById('undoBtn').addEventListener('click', function() {
     if (historyIndex > 0) {
        historyIndex--;
        canvas.loadFromJSON(history[historyIndex], function() {
            canvas.renderAll();
            updateSelectedObject();
            updateStatus(`Đã undo (${historyIndex}/${history.length-1})`);
            updateHistoryButtons();
            updateHistoryStatus();
        });
    }
});
document.getElementById('redoBtn').addEventListener('click', function() {
    if (historyIndex < history.length - 1) {
        historyIndex++;
        canvas.loadFromJSON(history[historyIndex], function() {
            canvas.renderAll();
            updateSelectedObject();
            updateStatus(`Đã redo (${historyIndex}/${history.length-1})`);
            updateHistoryButtons();
            updateHistoryStatus();
        });
    }
});

// ========== PHÍM TẮT (Đã cập nhật Lasso) ==========
document.addEventListener('keydown', function(e) {
    if (e.key.toLowerCase() === 'h' && currentToolMode !== 'hand') { 
        e.preventDefault(); 
        setToolMode('hand');
    } else if (e.key === 'Escape' || (e.ctrlKey && e.key === 't')) { 
        e.preventDefault(); 
        setToolMode('select');
    } else if (e.key.toLowerCase() === 'd') { 
        e.preventDefault(); 
        if (currentToolMode === 'draw') {
            setToolMode('select');
        } else {
            setToolMode('draw');
        }
    } else if (e.key.toLowerCase() === 'l') { 
        e.preventDefault(); 
        if (currentToolMode === 'lasso') {
            setToolMode('select');
        } else {
            setToolMode('lasso');
        }
    } else if (e.key.toLowerCase() === 'w') { 
        e.preventDefault(); 
        applyAutoWarp();
    } else if (e.ctrlKey && e.key === 'z') { 
        e.preventDefault(); 
        document.getElementById('undoBtn').click(); 
    } else if ((e.ctrlKey && e.key === 'y') || (e.ctrlKey && e.shiftKey && e.key === 'Z')) { 
        e.preventDefault(); 
        document.getElementById('redoBtn').click(); 
    } else if (e.key === 'Enter' && currentToolMode === 'lasso' && isLassoMode) { // Xử lý Enter trong Lasso
        e.preventDefault();
        finishLassoSelection();
    } else if (e.key === 'Delete' || e.key === 'Backspace') {
        e.preventDefault(); 
        if (currentToolMode === 'lasso' && lassoPoints.length >= 3) {
            deleteLassoArea();
        } else {
            document.getElementById('removeBtn').click(); 
        }
    }
});

canvas.on('selection:created', updateSelectedObject);
canvas.on('selection:updated', updateSelectedObject);
canvas.on('selection:cleared', updateSelectedObject);

function updateSelectedObject() {
    const activeObj = canvas.getActiveObject();
    const selectedObjElement = document.getElementById('selectedObj');
    
    if (activeObj && activeObj !== mockupImage) {
        selectedObjElement.textContent = activeObj.name === 'texture' ? 'Vật Liệu' : 'Đã chọn';
        selectedObjElement.style.color = '#4ecdc4';
    } else {
        selectedObjElement.textContent = 'Không có';
        selectedObjElement.style.color = '#ff6b6b';
    }
}

function updateStatus(message) {
    document.getElementById('statusText').textContent = message;
}

// ========== KHỞI TẠO ==========
function updateToolButtons() {
    document.querySelectorAll('.tools .tool-btn').forEach(btn => {
        btn.classList.remove('active-tool');
    });
    
    if (currentToolMode === 'hand') {
        document.getElementById('handToolBtn').classList.add('active-tool');
    } else if (currentToolMode === 'draw') {
        document.getElementById('drawBtn').classList.add('active-tool');
    } else if (currentToolMode === 'lasso') {
        document.getElementById('lassoBtn').classList.add('active-tool');
    } else {
        document.getElementById('transformBtn').classList.add('active-tool');
    }
}

// Gọi hàm khởi tạo lasso canvas
resizeCanvas();

setToolMode('select');
updateZoomDisplay();
updateStatus('Sẵn sàng - Tải mockup và ảnh vật liệu để bắt đầu');
updateSelectedObject();
updateHistoryButtons();
updateHistoryStatus();

document.getElementById('drawingColor').style.background = drawingBrush.color;

// Thiết lập Lasso Canvas Context
lassoCanvas = document.getElementById('lassoCanvas');
if (lassoCanvas) {
    lassoCtx = lassoCanvas.getContext('2d');
}

setTimeout(() => {
    saveToHistory();
}, 100);
