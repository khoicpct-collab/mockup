<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>MOCKUP K - Improved Lasso & Warp (Minimal)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Arial, Helvetica, sans-serif; margin: 0; display:flex; height:100vh; }
    #sidebar { width: 300px; padding:12px; border-right:1px solid #ddd; box-sizing:border-box; background:#fafafa; }
    #canvas-wrap { flex:1; display:flex; align-items:center; justify-content:center; background:#eee; }
    canvas { border:1px solid #aaa; background:white; }
    button, input, label { display:block; margin:8px 0; }
    .small { font-size:13px; }
    #status { margin-top:10px; color:#333; font-size:13px; min-height:18px; }
  </style>
</head>
<body>
  <div id="sidebar">
    <h3>MOCKUP K — Tools</h3>
    <label><input type="file" id="uploadMockup" accept="image/*" /> Tải mockup (background)</label>
    <label><input type="file" id="uploadTexture" accept="image/*" /> Tải vật liệu (texture)</label>

    <hr/>
    <button id="btnLassoMode">Bật Lasso</button>
    <button id="btnDeleteLasso">Xóa vùng Lasso (Feather)</button>
    <button id="btnWarpAuto">Warp Auto ( nâng cao )</button>

    <label class="small">Warp intensity <span id="warpVal">40</span></label>
    <input id="warpRange" type="range" min="0" max="200" value="40" />

    <label class="small">Feather (percent of min dim)</label>
    <input id="featherRange" type="range" min="0" max="10" value="1" />

    <div id="status">Sẵn sàng.</div>
  </div>

  <div id="canvas-wrap">
    <canvas id="c" width="1000" height="700"></canvas>
  </div>

  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/fabric@5.3.0/dist/fabric.min.js"></script>
  <!-- glfx.js (for displacement) - from CDN -->
  <script src="https://cdn.jsdelivr.net/gh/evanw/glfx.js/glfx.js"></script>

  <script>
  /*************************************************************************
   * Minimal Mockup K app with improved Lasso delete (feather) and Warp
   * - This is a self-contained example you can copy/paste.
   * - Replace or merge functions into your existing project as needed.
   *************************************************************************/

  const canvas = new fabric.Canvas('c', { preserveObjectStacking: true, selection: false });
  let mockupImage = null; // background mockup (fabric.Image)
  let currentTexture = null; // active texture (fabric.Image)
  let isLassoMode = false;
  let lassoPoints = [];
  let lassoLine = null;

  const statusEl = document.getElementById('status');
  function updateStatus(text) { statusEl.textContent = text; }

  // UI
  document.getElementById('uploadMockup').addEventListener('change', ev => {
    const f = ev.target.files[0]; if (!f) return;
    const url = URL.createObjectURL(f);
    fabric.Image.fromURL(url, img => {
      // fit to canvas
      img.set({ selectable:false, evented:false, left:0, top:0 });
      const ratio = Math.min(canvas.width / img.width, canvas.height / img.height);
      img.scale(ratio);
      canvas.clear();
      mockupImage = img;
      canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
      updateStatus('Mockup loaded.');
    });
  });

  document.getElementById('uploadTexture').addEventListener('change', ev => {
    const f = ev.target.files[0]; if (!f) return;
    const url = URL.createObjectURL(f);
    fabric.Image.fromURL(url, img => {
      img.set({
        left: 120, top: 80,
        scaleX: 0.6, scaleY: 0.6,
        cornerStyle: 'circle',
        cornerColor: '#4ecdc4',
        borderColor: '#4ecdc4',
        name: 'texture'
      });
      currentTexture = img;
      canvas.add(img);
      canvas.setActiveObject(img);
      updateStatus('Texture loaded. Kéo/thu phóng/góc để đặt.');
    });
  });

  // Lasso drawing handlers
  document.getElementById('btnLassoMode').addEventListener('click', () => {
    isLassoMode = !isLassoMode;
    document.getElementById('btnLassoMode').textContent = isLassoMode ? 'Tắt Lasso' : 'Bật Lasso';
    if (isLassoMode) {
      canvas.defaultCursor = 'crosshair';
      lassoPoints = [];
      if (lassoLine) { canvas.remove(lassoLine); lassoLine = null; }
      updateStatus('Đang ở chế độ Lasso: click để vẽ (double-click để đóng vùng).');
    } else {
      canvas.defaultCursor = 'default';
    }
  });

  // Mouse events for lasso (viewport coordinates)
  canvas.on('mouse:down', function(opt) {
    if (!isLassoMode) return;
    const pointer = canvas.getPointer(opt.e, true);
    lassoPoints.push({ x: pointer.x, y: pointer.y });
    redrawLassoPath();
  });

  canvas.on('mouse:dblclick', function(opt) {
    if (!isLassoMode) return;
    // close and finish
    isLassoMode = false;
    document.getElementById('btnLassoMode').textContent = 'Bật Lasso';
    updateStatus('Vùng đã đóng. Nhấn "Xóa vùng Lasso" để xóa (feather).');
  });

  function redrawLassoPath() {
    if (lassoLine) { canvas.remove(lassoLine); lassoLine = null; }
    if (lassoPoints.length < 2) return;
    const points = lassoPoints.reduce((acc, p) => acc.concat([p.x, p.y]), []);
    lassoLine = new fabric.Polygon(lassoPoints, {
      stroke: '#ff5722', strokeWidth: 2, fill: 'rgba(255,87,34,0.12)', selectable:false, evented:false
    });
    canvas.add(lassoLine);
    canvas.requestRenderAll();
  }

  document.getElementById('btnDeleteLasso').addEventListener('click', () => {
    // pass feather percent
    const featherPercent = Number(document.getElementById('featherRange').value) || 1;
    deleteLassoArea({ featherPercent });
  });

  /*************************************************************************
   * Improved deleteLassoArea: smooth feathered cut using mask canvas
   * - Uses fabric internals to map viewport lasso points into object-local image pixels
   **************************************************************************/
  function deleteLassoArea(options = {}) {
    if (!lassoPoints || lassoPoints.length < 3) {
      updateStatus('Vui lòng tạo vùng chọn trước khi xóa');
      return;
    }
    const activeObj = canvas.getActiveObject();
    if (!activeObj || activeObj.name !== 'texture') {
      updateStatus('Vui lòng chọn một vật liệu (texture) trước khi xóa vùng chọn');
      return;
    }

    const imgEl = activeObj.getElement();
    if (!imgEl) { updateStatus('Ảnh texture không hợp lệ'); return; }

    // Natural image size
    const imgW = imgEl.naturalWidth || imgEl.width;
    const imgH = imgEl.naturalHeight || imgEl.height;

    // Create canvases matching image natural resolution
    const srcCanvas = document.createElement('canvas');
    srcCanvas.width = imgW; srcCanvas.height = imgH;
    const srcCtx = srcCanvas.getContext('2d');

    const maskCanvas = document.createElement('canvas');
    maskCanvas.width = imgW; maskCanvas.height = imgH;
    const maskCtx = maskCanvas.getContext('2d');

    // Draw original texture into srcCanvas at natural resolution
    srcCtx.drawImage(imgEl, 0, 0, imgW, imgH);

    // Map lasso points viewport -> image-local using object's transform
    const matrix = activeObj.calcTransformMatrix();
    const inverted = fabric.util.invertTransform(matrix);

    maskCtx.fillStyle = 'black';
    maskCtx.fillRect(0, 0, maskCanvas.width, maskCanvas.height);
    maskCtx.beginPath();
    let p = fabric.util.transformPoint(new fabric.Point(lassoPoints[0].x, lassoPoints[0].y), inverted);
    maskCtx.moveTo(p.x, p.y);
    for (let i = 1; i < lassoPoints.length; i++) {
      let pp = fabric.util.transformPoint(new fabric.Point(lassoPoints[i].x, lassoPoints[i].y), inverted);
      maskCtx.lineTo(pp.x, pp.y);
    }
    maskCtx.closePath();
    maskCtx.fillStyle = 'white';
    maskCtx.fill();

    // Feather amount: percent of smaller dimension, default 1%
    const featherPct = options.featherPercent || Number(document.getElementById('featherRange').value) || 1;
    const blurPx = Math.max(0, Math.round(Math.min(imgW, imgH) * (featherPct / 100)));

    // Try canvas filter blur (modern browsers). Fallback to simple polygon cut
    try {
      const tmp = document.createElement('canvas');
      tmp.width = maskCanvas.width; tmp.height = maskCanvas.height;
      const tctx = tmp.getContext('2d');
      if (blurPx > 0) {
        tctx.filter = `blur(${blurPx}px)`;
      }
      tctx.drawImage(maskCanvas, 0, 0);
      tctx.filter = 'none';

      const maskData = tctx.getImageData(0, 0, tmp.width, tmp.height);
      const srcData = srcCtx.getImageData(0, 0, srcCanvas.width, srcCanvas.height);

      // Apply mask to source alpha: where mask is white (255) -> removed
      for (let i = 0; i < maskData.data.length; i += 4) {
        // grayscale mask
        const m = maskData.data[i]; // 0..255
        // We want white to remove -> alpha reduced
        const alphaFactor = 1 - (m / 255); // m=255 -> alphaFactor = 0 -> fully removed
        srcData.data[i + 3] = Math.round(srcData.data[i + 3] * alphaFactor);
      }
      srcCtx.putImageData(srcData, 0, 0);
    } catch (err) {
      // Fallback: use destination-out
      srcCtx.globalCompositeOperation = 'destination-out';
      srcCtx.drawImage(maskCanvas, 0, 0);
      srcCtx.globalCompositeOperation = 'source-over';
    }

    // Replace fabric object with new image preserving transforms
    const newDataUrl = srcCanvas.toDataURL();
    fabric.Image.fromURL(newDataUrl, function(newImg) {
      newImg.set({
        left: activeObj.left,
        top: activeObj.top,
        scaleX: activeObj.scaleX,
        scaleY: activeObj.scaleY,
        angle: activeObj.angle,
        opacity: activeObj.opacity,
        name: 'texture',
        cornerStyle: 'circle',
        cornerColor: '#4ecdc4',
        borderColor: '#4ecdc4',
        cornerSize: 12,
        transparentCorners: false
      });
      canvas.remove(activeObj);
      canvas.add(newImg);
      canvas.setActiveObject(newImg);
      cleanupLasso();
      canvas.requestRenderAll();
      updateStatus('Đã xóa vùng (feathered).');
    });
  }

  function cleanupLasso() {
    lassoPoints = [];
    if (lassoLine) { canvas.remove(lassoLine); lassoLine = null; }
    canvas.requestRenderAll();
  }

  /*************************************************************************
   * Warp Auto (improved)
   * - createAutoDisplacementMapForObject(obj, targetW, targetH) => returns Promise<HTMLImageElement>
   * - applyWarpWithSettings(obj, settings)
   *
   * Uses glfx.js (cpu/gpu) to apply heightField displacement and adds subtle shading.
   **************************************************************************/
  function createAutoDisplacementMapForObject(obj, targetW, targetH) {
    return new Promise((resolve, reject) => {
      if (!mockupImage || !obj) { reject(new Error('Chưa có mockup hoặc object')); return; }
      const mockEl = mockupImage.getElement();
      const mockW = mockEl.naturalWidth || mockEl.width;
      const mockH = mockEl.naturalHeight || mockEl.height;

      // Compute object's bbox in canvas coords, then to mockup image coords
      const objBbox = obj.getBoundingRect(true);
      const mockInv = fabric.util.invertTransform(mockupImage.calcTransformMatrix());
      const tl = fabric.util.transformPoint(new fabric.Point(objBbox.left, objBbox.top), mockInv);
      const br = fabric.util.transformPoint(new fabric.Point(objBbox.left + objBbox.width, objBbox.top + objBbox.height), mockInv);

      const sx = Math.max(0, Math.min(mockW, tl.x));
      const sy = Math.max(0, Math.min(mockH, tl.y));
      const sWidth = Math.max(1, Math.min(mockW - sx, br.x - tl.x));
      const sHeight = Math.max(1, Math.min(mockH - sy, br.y - tl.y));

      // Create temporary canvas sized to target displacement map
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = Math.max(1, targetW);
      tempCanvas.height = Math.max(1, targetH);
      const ctx = tempCanvas.getContext('2d');

      // Draw scaled crop of mockup into temp canvas
      ctx.drawImage(mockEl, sx, sy, sWidth, sHeight, 0, 0, tempCanvas.width, tempCanvas.height);

      // Convert to grayscale + increase contrast slightly
      try {
        let id = ctx.getImageData(0,0,tempCanvas.width,tempCanvas.height);
        let d = id.data;
        for (let i=0;i<d.length;i+=4){
          let lum = 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2];
          lum = (lum - 128) * 1.4 + 128; // contrast boost
          lum = Math.max(0, Math.min(255, lum));
          d[i] = d[i+1] = d[i+2] = lum;
        }
        ctx.putImageData(id,0,0);
      } catch(e) {
        // ignore
      }

      // Soft blur to avoid harsh displacement
      try {
        const blurPx = Math.max(1, Math.round(Math.min(tempCanvas.width, tempCanvas.height) * 0.01));
        const tmp = document.createElement('canvas');
        tmp.width = tempCanvas.width; tmp.height = tempCanvas.height;
        const tctx = tmp.getContext('2d');
        tctx.filter = `blur(${blurPx}px)`;
        tctx.drawImage(tempCanvas, 0, 0);
        tctx.filter = 'none';
        const img = new Image();
        img.onload = () => resolve(img);
        img.src = tmp.toDataURL();
      } catch (err) {
        const img = new Image();
        img.onload = () => resolve(img);
        img.src = tempCanvas.toDataURL();
      }
    });
  }

  function applyWarpWithSettings(obj, settings = {}) {
    const imgEl = obj.getElement();
    if (!imgEl) { updateStatus('Ảnh vật liệu không hợp lệ'); return; }

    const texW = imgEl.naturalWidth || imgEl.width;
    const texH = imgEl.naturalHeight || imgEl.height;
    updateStatus('Đang áp dụng Warp (nâng cao)...');

    createAutoDisplacementMapForObject(obj, texW, texH).then(dispImg => {
      try {
        // create glfx canvas and textures
        const fxCanvas = fx.canvas();
        const tex = fxCanvas.texture(imgEl);
        const disp = fxCanvas.texture(dispImg);

        fxCanvas.draw(tex).update();

        // compute strength heuristically
        const diag = Math.sqrt(texW*texW + texH*texH);
        const baseStrength = (settings.dispIntensity || Number(document.getElementById('warpRange').value) || 40) / 100; // 0..2
        const strength = Math.max(0.01, baseStrength * (diag / 500));

        // apply heightField / displacement
        if (disp) {
          // heightField expects small numbers; scale down
          fxCanvas.heightField(disp, Math.min(0.9, strength * 0.2)).update();
        }

        // optional mild bulge for realism
        if (settings.bulge && settings.bulge > 0) {
          fxCanvas.bulgePinch(0.5, 0.5, Math.min(0.9, settings.bulge/100 * 0.6), 0.9).update();
        }

        const warpedDataUrl = fxCanvas.toDataURL();

        // add subtle shading/highlight on top for depth
        const shadowCanvas = document.createElement('canvas');
        shadowCanvas.width = texW; shadowCanvas.height = texH;
        const sctx = shadowCanvas.getContext('2d');
        const warpedImg = new Image();
        warpedImg.onload = function() {
          sctx.drawImage(warpedImg, 0, 0, texW, texH);

          // multiply-ish darken to simulate fold shadows
          sctx.globalCompositeOperation = 'source-over';
          sctx.fillStyle = 'rgba(0,0,0,0.08)';
          sctx.fillRect(0,0,texW,texH);

          // gentle highlight
          sctx.globalCompositeOperation = 'lighter';
          const grad = sctx.createRadialGradient(texW*0.4, texH*0.3, 0, texW*0.4, texH*0.3, Math.max(texW,texH)*0.8);
          grad.addColorStop(0, 'rgba(255,255,255,0.03)');
          grad.addColorStop(1, 'rgba(255,255,255,0.0)');
          sctx.fillStyle = grad;
          sctx.fillRect(0,0,texW,texH);

          // Replace object with new image preserving transforms
          fabric.Image.fromURL(shadowCanvas.toDataURL(), function(finalImg) {
            finalImg.set({
              left: obj.left,
              top: obj.top,
              scaleX: obj.scaleX,
              scaleY: obj.scaleY,
              angle: obj.angle,
              name: 'texture',
              cornerStyle: 'circle',
              cornerColor: '#4ecdc4',
              borderColor: '#4ecdc4',
              cornerSize: 12,
              transparentCorners: false
            });
            canvas.remove(obj);
            canvas.add(finalImg);
            canvas.setActiveObject(finalImg);
            canvas.requestRenderAll();
            updateStatus('Warp auto áp dụng xong.');
          });
        };
        warpedImg.src = warpedDataUrl;
      } catch (err) {
        console.error('Warp error', err);
        updateStatus('Lỗi khi áp dụng Warp. Kiểm tra console.');
      }
    }).catch(err => {
      console.error('Create displacement failed', err);
      updateStatus('Không thể tạo displacement map cho vật liệu.');
    });
  }

  // Hook warp button
  document.getElementById('btnWarpAuto').addEventListener('click', () => {
    const obj = canvas.getActiveObject();
    if (!obj || obj.name !== 'texture') { updateStatus('Chọn vật liệu trước khi áp dụng Warp'); return; }
    const settings = {
      dispIntensity: Number(document.getElementById('warpRange').value),
      bulge: 10,
      warpX: 0,
      warpY: 0,
      blend: 60
    };
    applyWarpWithSettings(obj, settings);
  });

  // warp range display
  const wr = document.getElementById('warpRange');
  const wv = document.getElementById('warpVal');
  wr.addEventListener('input', () => { wv.textContent = wr.value; });

  // keyboard: press Esc to cancel lasso
  document.addEventListener('keydown', e => {
    if (e.key === 'Escape') {
      isLassoMode = false;
      document.getElementById('btnLassoMode').textContent = 'Bật Lasso';
      cleanupLasso();
      updateStatus('Đã hủy Lasso.');
    }
  });

  // small helper save history stub (integrate with your existing undo)
  function saveToHistory() {
    // placeholder: integrate with your project's history/undo system
    // e.g., store canvas.toJSON() snapshots
    // console.log('Saved state to history (stub).');
  }

  // initial guidance
  updateStatus('Tải mockup và texture để bắt đầu. Sử dụng Lasso để chọn vùng và xóa (feather), Warp Auto để tạo effect.');
  </script>
</body>
</html>
